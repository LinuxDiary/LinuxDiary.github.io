(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{219:function(a,e,s){"use strict";s.r(e);var v=s(6),t=Object(v.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"双网卡绑定和负载均衡"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#双网卡绑定和负载均衡"}},[a._v("#")]),a._v(" 双网卡绑定和负载均衡")]),a._v(" "),e("h2",{attrs:{id:"关闭networkmanager"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关闭networkmanager"}},[a._v("#")]),a._v(" 关闭NetworkManager")]),a._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[a._v("service")]),a._v(" NetworkManager stop\n"),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("chkconfig")]),a._v(" NetworkManager off\n")])])]),e("h2",{attrs:{id:"创建bond0接口配置文件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#创建bond0接口配置文件"}},[a._v("#")]),a._v(" 创建bond0接口配置文件")]),a._v(" "),e("p",[a._v("在 "),e("code",[a._v("/etc/sysconfig/network-script/")]),a._v(" 目录下创建 "),e("code",[a._v("ifcfg-bond0")]),a._v(" 配置文件")]),a._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("DEVICE")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("bond0\n"),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("IPADDR")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("192.168")]),a._v(".100.106\n"),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("PREFIX")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("24")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("GATEWAY")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("192.168")]),a._v(".100.1\n"),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("DNS1")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("202.103")]),a._v(".24.68\n"),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("BOOTPROTO")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("static\n"),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("ONBOOT")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("yes\n"),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("USERCTL")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("no\n")])])]),e("h2",{attrs:{id:"修改eth0和eth1的配置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#修改eth0和eth1的配置"}},[a._v("#")]),a._v(" 修改eth0和eth1的配置")]),a._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# ifcfg-eth0")]),a._v("\n\n"),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("DEVICE")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("eth0\n"),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("BOOTPROTO")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("none\n"),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("ONBOOT")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("yes\n"),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("MASTER")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("bond0\n"),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("SLAVE")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("yes\n"),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("USERCTL")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("no\n")])])]),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# ifcfg-eth1")]),a._v("\n\n"),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("DEVICE")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("eth1\n"),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("BOOTPROTO")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("none\n"),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("ONBOOT")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("yes\n"),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("MASTER")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("bond0\n"),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("SLAVE")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("yes\n"),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("USERCTL")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("no\n")])])]),e("h2",{attrs:{id:"加载bonding模块"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#加载bonding模块"}},[a._v("#")]),a._v(" 加载bonding模块")]),a._v(" "),e("p",[a._v("新建 "),e("code",[a._v("/etc/modprobe.d/bonding.conf")]),a._v(" 配置文件")]),a._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v("alias")]),a._v(" bond0 bonding\noptions bond0 "),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("miimon")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("100")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("mode")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("6")]),a._v("\n")])])]),e("p",[e("code",[a._v("miimon")]),a._v(" 是用来进行链路监测的。 比如： "),e("code",[a._v("miimon=100")]),a._v(" ，单位是 "),e("code",[a._v("ms")]),a._v(" (毫秒)。这里的 "),e("code",[a._v("100")]),a._v(" ，是 "),e("code",[a._v("100ms")]),a._v(" ，即是 "),e("code",[a._v("0.1")]),a._v(" 秒。系统每 "),e("code",[a._v("100ms")]),a._v(" 监测一次链路连接状态，如果有一条线路不通就转入另一条线路。 "),e("code",[a._v("mode")]),a._v(" 是指工作模式，总共有七种（ "),e("code",[a._v("0-6")]),a._v(" ）。这两个参数可以配置在 "),e("code",[a._v("/etc/modprobe.d/bonding.conf")]),a._v(" 文件里，即 "),e("code",[a._v("options bond0 miimon=100 mode=6")]),a._v(" ，或者直接写在 "),e("code",[a._v("bond0")]),a._v(" 的配置文件中，即 "),e("code",[a._v('BONDING_OPTS="mode=6 miimon=100"')]),a._v(" ，设置好之后重启网络服务")]),a._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[a._v("service")]),a._v(" network restart\n")])])]),e("h2",{attrs:{id:"查看bond0接口状态"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#查看bond0接口状态"}},[a._v("#")]),a._v(" 查看bond0接口状态")]),a._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[a._v("$ "),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("cat")]),a._v(" /proc/net/bonding/bond0\nEthernet Channel Bonding Driver: v3.7.1 "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("April "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("27")]),a._v(", "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("2011")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\nBonding Mode: adaptive load balancing\nPrimary Slave: None\nCurrently Active Slave: eth0\nMII Status: up\nMII Polling Interval "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("ms"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(": "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("100")]),a._v("\nUp Delay "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("ms"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(": "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("\nDown Delay "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("ms"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(": "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("\n\nSlave Interface: eth0\nMII Status: up\nSpeed: "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("100")]),a._v(" Mbps\nDuplex: full\nLink Failure Count: "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("\nPermanent HW addr: "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("52")]),a._v(":54:00:a9:4e:2c\nSlave queue ID: "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("\n\nSlave Interface: eth1\nMII Status: up\nSpeed: "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("100")]),a._v(" Mbps\nDuplex: full\nLink Failure Count: "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("\nPermanent HW addr: "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("52")]),a._v(":54:00:91:1b:68\nSlave queue ID: "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v("\n")])])]),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[a._v("TIP")]),a._v(" "),e("p",[a._v("如果多次修改过 "),e("code",[a._v("bond")]),a._v(" 配置，则可能需要重启系统， "),e("code",[a._v("bond0")]),a._v(" 接口状态才会更新。")])]),a._v(" "),e("h2",{attrs:{id:"查看网络接口收发状态"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#查看网络接口收发状态"}},[a._v("#")]),a._v(" 查看网络接口收发状态")]),a._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[a._v("watch")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-n")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("ifconfig")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-a")]),a._v("\n")])])]),e("h2",{attrs:{id:"bond的七种工作模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bond的七种工作模式"}},[a._v("#")]),a._v(" bond的七种工作模式")]),a._v(" "),e("h3",{attrs:{id:"mode-0-balance-rr-平衡抡循环策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mode-0-balance-rr-平衡抡循环策略"}},[a._v("#")]),a._v(" mode=0(balance-rr)(平衡抡循环策略)")]),a._v(" "),e("p",[a._v("链路负载均衡，增加带宽，支持容错，一条链路故障会自动切换正常链路。交换机需要配置聚合口，思科叫 "),e("code",[a._v("port channel")]),a._v(" 。")]),a._v(" "),e("p",[a._v("特点：传输数据包顺序是依次传输（即：第 "),e("code",[a._v("1")]),a._v(" 个包走 "),e("code",[a._v("eth0")]),a._v(" ，下一个包就走 "),e("code",[a._v("eth1…")]),a._v(" .一直循环下去，直到最后一个传输完毕），此模式提供负载平衡和容错能力；但是如果一个连接或者会话的数据包从不同的接口发出的话，中途再经过不同的链路，在客户端很有可能会出现数据包无序到达的问题，而无序到达的数据包需要重新要求被发送，这样网络的吞吐量就会下降")]),a._v(" "),e("h3",{attrs:{id:"mode-1-active-backup-主-备份策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mode-1-active-backup-主-备份策略"}},[a._v("#")]),a._v(" mode=1(active-backup)(主-备份策略)")]),a._v(" "),e("p",[a._v("这个是主备模式，只有一块网卡是 "),e("code",[a._v("active")]),a._v(" ，另一块是备用的 "),e("code",[a._v("standby")]),a._v(" ，所有流量都在 "),e("code",[a._v("active")]),a._v(" 链路上处理，交换机配置的是捆绑的话将不能工作，因为交换机往两块网卡发包，有一半包是丢弃的。")]),a._v(" "),e("p",[a._v("特点：只有一个设备处于活动状态，当一个宕掉另一个马上由备份转换为主设备。 "),e("code",[a._v("mac")]),a._v(" 地址是外部可见得，从外面看来， "),e("code",[a._v("bond")]),a._v(" 的 "),e("code",[a._v("MAC")]),a._v(" 地址是唯一的，以避免 "),e("code",[a._v("switch")]),a._v(" (交换机)发生混乱。此模式只提供了容错能力；由此可见此算法的优点是可以提供高网络连接的可用性，但是它的资源利用率较低，只有一个接口处于工作状态，在有 "),e("code",[a._v("N")]),a._v(" 个网络接口的情况下，资源利用率为 "),e("code",[a._v("1/N")])]),a._v(" "),e("h3",{attrs:{id:"mode-2-balance-xor-平衡策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mode-2-balance-xor-平衡策略"}},[a._v("#")]),a._v(" mode=2(balance-xor)(平衡策略)")]),a._v(" "),e("p",[a._v("表示 "),e("code",[a._v("XOR Hash")]),a._v(" 负载分担，和交换机的聚合强制不协商方式配合。（需要 "),e("code",[a._v("xmit_hash_policy")]),a._v(" ，需要交换机配置 "),e("code",[a._v("port channel")]),a._v(" ）\n特点：基于指定的传输HASH策略传输数据包。缺省的策略是：(源 "),e("code",[a._v("MAC")]),a._v(" 地址 "),e("code",[a._v("XOR")]),a._v(" 目标 "),e("code",[a._v("MAC")]),a._v(" 地址) "),e("code",[a._v("% slave")]),a._v("数量。其他的传输策略可以通过 "),e("code",[a._v("xmit_hash_policy")]),a._v(" 选项指定，此模式提供负载平衡和容错能力")]),a._v(" "),e("h3",{attrs:{id:"mode-3-broadcast-广播策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mode-3-broadcast-广播策略"}},[a._v("#")]),a._v(" mode=3(broadcast)(广播策略)")]),a._v(" "),e("p",[a._v("表示所有包从所有网络接口发出，这个不均衡，只有冗余机制，但过于浪费资源。此模式适用于金融行业，因为他们需要高可靠性的网络，不允许出现任何问题。需要和交换机的聚合强制不协商方式配合。")]),a._v(" "),e("p",[a._v("特点：在每个 "),e("code",[a._v("slave")]),a._v(" 接口上传输每个数据包，此模式提供了容错能力")]),a._v(" "),e("h3",{attrs:{id:"mode-4-802-3ad-ieee-802-3ad-动态链接聚合"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mode-4-802-3ad-ieee-802-3ad-动态链接聚合"}},[a._v("#")]),a._v(" mode=4(802.3ad)(IEEE 802.3ad 动态链接聚合)")]),a._v(" "),e("p",[a._v("表示支持 "),e("code",[a._v("802.3ad")]),a._v(" 协议，和交换机的聚合 "),e("code",[a._v("LACP")]),a._v(" 方式配合（需要 "),e("code",[a._v("xmit_hash_policy")]),a._v(" ）.标准要求所有设备在聚合操作时，要在同样的速率和双工模式，而且，和除了 "),e("code",[a._v("balance-rr")]),a._v(" 模式外的其它 "),e("code",[a._v("bonding")]),a._v(" 负载均衡模式一样，任何连接都不能使用多于一个接口的带宽。")]),a._v(" "),e("p",[a._v("特点：创建一个聚合组，它们共享同样的速率和双工设定。根据 "),e("code",[a._v("802.3ad")]),a._v(" 规范将多个 "),e("code",[a._v("slave")]),a._v(" 工作在同一个激活的聚合体下。")]),a._v(" "),e("p",[a._v("外出流量的 "),e("code",[a._v("slave")]),a._v(" 选举是基于传输 "),e("code",[a._v("hash")]),a._v(" 策略，该策略可以通过 "),e("code",[a._v("xmit_hash_policy")]),a._v(" 选项从缺省的 "),e("code",[a._v("XOR")]),a._v(" 策略改变到其他策略。需要注意的是，并不是所有的传输策略都是 "),e("code",[a._v("802.3ad")]),a._v(" 适应的，尤其考虑到在 "),e("code",[a._v("802.3ad")]),a._v(" 标准 "),e("code",[a._v("43.2.4")]),a._v(" 章节提及的包乱序问题。不同的实现可能会有不同的适应性。")]),a._v(" "),e("p",[a._v("必要条件：\n条件1： "),e("code",[a._v("ethtool")]),a._v(" 支持获取每个 "),e("code",[a._v("slave")]),a._v(" 的速率和双工设定\n条件2： "),e("code",[a._v("switch")]),a._v(" (交换机)支持 "),e("code",[a._v("IEEE 802.3ad Dynamic link aggregation")]),a._v("\n条件3： 大多数 "),e("code",[a._v("switch")]),a._v(" (交换机)需要经过特定配置才能支持 "),e("code",[a._v("802.3ad")]),a._v(" 模式")]),a._v(" "),e("h3",{attrs:{id:"mode-5-balance-tlb-适配器传输负载均衡"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mode-5-balance-tlb-适配器传输负载均衡"}},[a._v("#")]),a._v(" mode=5(balance-tlb)(适配器传输负载均衡)")]),a._v(" "),e("p",[a._v("是根据每个 "),e("code",[a._v("slave")]),a._v(" 的负载情况选择 "),e("code",[a._v("slave")]),a._v(" 进行发送，接收时使用当前轮到的 "),e("code",[a._v("slave")]),a._v(" 。该模式要求 "),e("code",[a._v("slave")]),a._v(" 接口的网络设备驱动有某种 "),e("code",[a._v("ethtool")]),a._v(" 支持；而且 "),e("code",[a._v("ARP")]),a._v(" 监控不可用。")]),a._v(" "),e("p",[a._v("特点：不需要任何特别的 "),e("code",[a._v("switch")]),a._v(" (交换机)支持的通道 "),e("code",[a._v("bonding")]),a._v(" 。在每个 "),e("code",[a._v("slave")]),a._v(" 上根据当前的负载（根据速度计算）分配外出流量。如果正在接受数据的 "),e("code",[a._v("slave")]),a._v(" 出故障了，另一个 "),e("code",[a._v("slave")]),a._v(" 接管失败的 "),e("code",[a._v("slave")]),a._v(" 的 "),e("code",[a._v("MAC")]),a._v(" 地址。")]),a._v(" "),e("p",[a._v("必要条件： "),e("code",[a._v("ethtool")]),a._v(" 支持获取每个 "),e("code",[a._v("slave")]),a._v(" 的速率")]),a._v(" "),e("h3",{attrs:{id:"mode-6-balance-alb-适配器适应性负载均衡"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mode-6-balance-alb-适配器适应性负载均衡"}},[a._v("#")]),a._v(" mode=6(balance-alb)(适配器适应性负载均衡)")]),a._v(" "),e("p",[a._v("在 "),e("code",[a._v("5")]),a._v(" 的 "),e("code",[a._v("tlb")]),a._v(" 基础上增加了 "),e("code",[a._v("rlb")]),a._v(" (接收负载均衡 "),e("code",[a._v("receive load balance")]),a._v(" ).不需要任何 "),e("code",[a._v("switch")]),a._v(" (交换机)的支持。接收负载均衡是通过 "),e("code",[a._v("ARP")]),a._v(" 协商实现的.")]),a._v(" "),e("p",[a._v("特点：该模式包含了 "),e("code",[a._v("balance-tlb")]),a._v(" 模式，同时加上针对 "),e("code",[a._v("IPV4")]),a._v(" 流量的接收负载均衡( "),e("code",[a._v("receive load balance, rlb")]),a._v(" )，而且不需要任何 "),e("code",[a._v("switch")]),a._v(" (交换机)的支持。接收负载均衡是通过 "),e("code",[a._v("ARP")]),a._v(" 协商实现的。 "),e("code",[a._v("bonding")]),a._v(" 驱动截获本机发送的 "),e("code",[a._v("ARP")]),a._v(" 应答，并把源硬件地址改写为 "),e("code",[a._v("bond")]),a._v(" 中某个 "),e("code",[a._v("slave")]),a._v(" 的唯一硬件地址，从而使得不同的对端使用不同的硬件地址进行通信。来自服务器端的接收流量也会被均衡。当本机发送 "),e("code",[a._v("ARP")]),a._v(" 请求时， "),e("code",[a._v("bonding")]),a._v(" 驱动把对端的 "),e("code",[a._v("IP")]),a._v(" 信息从 "),e("code",[a._v("ARP")]),a._v(" 包中复制并保存下来。当 "),e("code",[a._v("ARP")]),a._v(" 应答从对端到达 时， "),e("code",[a._v("bonding")]),a._v(" 驱动把它的硬件地址提取出来，并发起一个 "),e("code",[a._v("ARP")]),a._v(" 应答给 "),e("code",[a._v("bond")]),a._v(" 中的某个 "),e("code",[a._v("slave")]),a._v(" 。")]),a._v(" "),e("p",[a._v("使用 "),e("code",[a._v("ARP")]),a._v(" 协商进行负载均衡的一个问题是：每次广播 "),e("code",[a._v("ARP")]),a._v(" 请求时都会使用 "),e("code",[a._v("bond")]),a._v(" 的硬件地址，因此对端学习到这个硬件地址后，接收流量将会全部流向当前的 "),e("code",[a._v("slave")]),a._v(" 。这个问题可以通过给所有的对端发送更新 （ "),e("code",[a._v("ARP")]),a._v(" 应答）来解决，应答中包含他们独一无二的硬件地址，从而导致流量重新分布。")]),a._v(" "),e("p",[a._v("当新的 "),e("code",[a._v("slave")]),a._v(" 加入到 "),e("code",[a._v("bond")]),a._v(" 中时，或者某个未激活的 "),e("code",[a._v("slave")]),a._v(" 重新 激活时，接收流量也要重新分布。接收的负载被顺序地分布（ "),e("code",[a._v("round robin")]),a._v(" ）在 "),e("code",[a._v("bond")]),a._v(" 中最高速的 "),e("code",[a._v("slave")]),a._v(" 上")]),a._v(" "),e("p",[a._v("当某个链路被重新接上，或者一个新的 "),e("code",[a._v("slave")]),a._v(" 加入到 "),e("code",[a._v("bond")]),a._v(" 中，接收流量在所有当前激活的 "),e("code",[a._v("slave")]),a._v(" 中全部重新分配，通过使用指定的 "),e("code",[a._v("MAC")]),a._v(" 地址给每个 "),e("code",[a._v("client")]),a._v(" 发起 "),e("code",[a._v("ARP")]),a._v(" 应答。下面介绍的 "),e("code",[a._v("updelay")]),a._v(" 参数必须被设置为某个大于等于 "),e("code",[a._v("switch")]),a._v(" (交换机)转发延时的值，从而保证发往对端的 "),e("code",[a._v("ARP")]),a._v(" 应答 不会被 "),e("code",[a._v("switch")]),a._v(" (交换机)阻截。")]),a._v(" "),e("p",[a._v("必要条件：\n条件1： "),e("code",[a._v("ethtool")]),a._v(" 支持获取每个 "),e("code",[a._v("slave")]),a._v(" 的速率；\n条件2： 底层驱动支持设置某个设备的硬件地址，从而使得总是有个 "),e("code",[a._v("slave(curr_active_slave)")]),a._v(" 使用 "),e("code",[a._v("bond")]),a._v(" 的硬件地址，同时保证每个 "),e("code",[a._v("bond")]),a._v(" 中的 "),e("code",[a._v("slave")]),a._v(" 都有一个唯一的硬件地址。如果 "),e("code",[a._v("curr_active_slave")]),a._v(" 出故障，它的硬件地址将会被新选出来的 "),e("code",[a._v("curr_active_slave")]),a._v(" 接管其实 "),e("code",[a._v("mod=6")]),a._v(" 与 "),e("code",[a._v("mod=0")]),a._v(" 的区别： "),e("code",[a._v("mod=6")]),a._v(" ，先把 "),e("code",[a._v("eth0")]),a._v(" 流量占满，再占 "),e("code",[a._v("eth1，….ethX")]),a._v("； 而 "),e("code",[a._v("mod=0")]),a._v(" 的话，会发现 "),e("code",[a._v("2")]),a._v(" 个口的流量都很稳定，基本一样的带宽。而 "),e("code",[a._v("mod=6")]),a._v(" ，会发现第一个口流量很高，第 "),e("code",[a._v("2")]),a._v(" 个口只占了小部分流量。")]),a._v(" "),e("p",[e("code",[a._v("mode5")]),a._v(" 和 "),e("code",[a._v("mode6")]),a._v(" 不需要交换机端的设置，网卡能自动聚合。 "),e("code",[a._v("mode4")]),a._v(" 需要支持 "),e("code",[a._v("802.3ad")]),a._v(" 。 "),e("code",[a._v("mode0")]),a._v(" "),e("code",[a._v("，mode2")]),a._v(" 和 "),e("code",[a._v("mode3")]),a._v(" 理论上需要静态聚合方式。但实测中 "),e("code",[a._v("mode0")]),a._v(" 可以通过 "),e("code",[a._v("mac")]),a._v(" 地址欺骗的方式在交换机不设置的情况下不太均衡地进行接收。")])])}),[],!1,null,null,null);e.default=t.exports}}]);